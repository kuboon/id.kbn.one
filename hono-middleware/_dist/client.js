function u(e){let t=new Uint8Array(e),r="";for(let n of t)r+=String.fromCharCode(n);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function h(e){let t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,a=t.padEnd(t.length+r,"="),n=atob(a),o=new ArrayBuffer(n.length),i=new Uint8Array(o);for(let s=0;s<n.length;s++)i[s]=n.charCodeAt(s);return o}function p(){return L.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}var L={stubThis:e=>e};function A(e){let{id:t}=e;return{...e,id:h(t),transports:e.transports}}function y(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}var c=class extends Error{constructor({message:t,code:r,cause:a,name:n}){super(t,{cause:a}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=n??a.name,this.code=r}};function C({error:e,options:t}){let{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new c({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(r.authenticatorSelection?.requireResidentKey===!0)return new c({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&r.authenticatorSelection?.userVerification==="required")return new c({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(r.authenticatorSelection?.userVerification==="required")return new c({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new c({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new c({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return r.pubKeyCredParams.filter(n=>n.type==="public-key").length===0?new c({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new c({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){let a=globalThis.location.hostname;if(y(a)){if(r.rp.id!==a)return new c({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new c({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new c({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new c({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}var I=class{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){let r=new Error("Cancelling existing WebAuthn API call for new one");r.name="AbortError",this.controller.abort(r)}let t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){let t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}},E=new I;var J=["cross-platform","platform"];function S(e){if(e&&!(J.indexOf(e)<0))return e}async function N(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});let{optionsJSON:t,useAutoRegister:r=!1}=e;if(!p())throw new Error("WebAuthn is not supported in this browser");let a={...t,challenge:h(t.challenge),user:{...t.user,id:h(t.user.id)},excludeCredentials:t.excludeCredentials?.map(A)},n={};r&&(n.mediation="conditional"),n.publicKey=a,n.signal=E.createNewAbortSignal();let o;try{o=await navigator.credentials.create(n)}catch(d){throw C({error:d,options:n})}if(!o)throw new Error("Registration was not completed");let{id:i,rawId:s,response:l,type:T}=o,f;typeof l.getTransports=="function"&&(f=l.getTransports());let R;if(typeof l.getPublicKeyAlgorithm=="function")try{R=l.getPublicKeyAlgorithm()}catch(d){_("getPublicKeyAlgorithm()",d)}let g;if(typeof l.getPublicKey=="function")try{let d=l.getPublicKey();d!==null&&(g=u(d))}catch(d){_("getPublicKey()",d)}let w;if(typeof l.getAuthenticatorData=="function")try{w=u(l.getAuthenticatorData())}catch(d){_("getAuthenticatorData()",d)}return{id:i,rawId:u(s),response:{attestationObject:u(l.attestationObject),clientDataJSON:u(l.clientDataJSON),transports:f,publicKeyAlgorithm:R,publicKey:g,authenticatorData:w},type:T,clientExtensionResults:o.getClientExtensionResults(),authenticatorAttachment:S(o.authenticatorAttachment)}}function _(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function x(){if(!p())return P.stubThis(new Promise(t=>t(!1)));let e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?P.stubThis(new Promise(t=>t(!1))):P.stubThis(e.isConditionalMediationAvailable())}var P={stubThis:e=>e};function D({error:e,options:t}){let{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new c({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new c({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){let a=globalThis.location.hostname;if(y(a)){if(r.rpId!==a)return new c({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new c({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new c({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function U(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});let{optionsJSON:t,useBrowserAutofill:r=!1,verifyBrowserAutofillInput:a=!0}=e;if(!p())throw new Error("WebAuthn is not supported in this browser");let n;t.allowCredentials?.length!==0&&(n=t.allowCredentials?.map(A));let o={...t,challenge:h(t.challenge),allowCredentials:n},i={};if(r){if(!await x())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&a)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');i.mediation="conditional",o.allowCredentials=[]}i.publicKey=o,i.signal=E.createNewAbortSignal();let s;try{s=await navigator.credentials.get(i)}catch(w){throw D({error:w,options:i})}if(!s)throw new Error("Authentication was not completed");let{id:l,rawId:T,response:f,type:R}=s,g;return f.userHandle&&(g=u(f.userHandle)),{id:l,rawId:u(T),response:{authenticatorData:u(f.authenticatorData),clientDataJSON:u(f.clientDataJSON),signature:u(f.signature),userHandle:g},type:R,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:S(s.authenticatorAttachment)}}function Ee(){return p()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}var W="/webauthn",v=null,B=e=>{if(!e||e==="/")return"";let t=e.startsWith("/")?e:`/${e}`;return t.endsWith("/")?t.slice(0,-1):t},K=e=>{let t=e.headers.get("content-type");return!!(t&&t.toLowerCase().includes("json"))},H=(e,t)=>{if(typeof e=="string"&&e.trim())return e;if(e&&typeof e=="object"&&"message"in e){let r=e.message;if(typeof r=="string"&&r.trim())return r}return t},O=class extends Error{status;details;constructor(t,r,a){super(t),this.status=r,this.details=a}},m=(e,t)=>{let r=`${e}${t}`;return v?new URL(r,v).toString():r},b=async(e,t,r)=>{let a=new Headers(r?.headers);r?.body&&!a.has("Content-Type")&&a.set("Content-Type","application/json");let n=await e(t,{credentials:"include",...r,headers:a});if(!n.ok){let i=null;try{if(K(n))i=await n.clone().json();else{let l=await n.clone().text();i=l.trim()?l:null}}catch{i=null}let s=H(i,n.statusText||`Request failed with status ${n.status}`);throw new O(s,n.status,i)}if(n.status===204)return null;if(K(n))return n.json();let o=await n.text();return o?JSON.parse(o):null},Le=(e={})=>{let t=B(e.mountPath??W),r=e.fetch??fetch,a=n=>n.trim();return{async register(n){let o=a(n.username),i=await b(r,m(t,"/register/options"),{method:"POST",body:JSON.stringify({username:o})}),s=await N({optionsJSON:i});return await b(r,m(t,"/register/verify"),{method:"POST",body:JSON.stringify({username:o,credential:s})})},async authenticate(n){let o=a(n.username),i=await b(r,m(t,"/authenticate/options"),{method:"POST",body:JSON.stringify({username:o})}),s=await U({optionsJSON:i});return await b(r,m(t,"/authenticate/verify"),{method:"POST",body:JSON.stringify({username:o,credential:s})})},async list(){let n=m(t,"/credentials"),o=await b(r,n),i=o&&typeof o=="object"&&"credentials"in o?o.credentials??[]:[];return Array.isArray(i)?i:[]},async delete(n){let o=n.credentialId,i=m(t,`/credentials/${encodeURIComponent(o)}`);await b(r,i,{method:"DELETE"})},async update(n){let o=n.credentialId,i=m(t,`/credentials/${encodeURIComponent(o)}`),s=await b(r,i,{method:"PATCH",body:JSON.stringify({nickname:n.nickname})});if(s&&typeof s=="object"&&"credential"in s)return s.credential;throw new O("Unexpected response when updating credential",500,s)}}};export{E as WebAuthnAbortService,c as WebAuthnError,P as _browserSupportsWebAuthnAutofillInternals,L as _browserSupportsWebAuthnInternals,h as base64URLStringToBuffer,p as browserSupportsWebAuthn,x as browserSupportsWebAuthnAutofill,u as bufferToBase64URLString,Le as createClient,Ee as platformAuthenticatorIsAvailable,U as startAuthentication,N as startRegistration};
