<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>kbn.one ID central</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="page">
      <header class="page-header">
        <div class="brand">
          <h1 id="brand">kbn.one ID central</h1>
        </div>
      </header>

      <section id="guest-view" class="panel">
        <div class="card">
          <form id="guest-form" class="stack" autocomplete="off">
            <div class="button-row align-start">
              <button type="submit" id="passkey-entry" class="primary">
                Sign Up / Sign In
              </button>
            </div>
          </form>
          <p id="conditional-status" class="hint" data-state="pending">
            パスキーの自動入力に対応しているか確認しています…
          </p>
        </div>
      </section>

      <section id="account-view" class="panel" hidden>
        <div class="card">
          <header class="section-header">
            <div>
              <h2>プロフィール情報</h2>
              <p class="hint" id="account-summary">
                サインイン中のユーザー情報が表示されます。
              </p>
            </div>
            <div class="section-actions">
              <button type="button" id="logout" class="secondary">
                ログアウト
              </button>
              <button type="button" id="delete-account" class="danger">
                アカウントを削除
              </button>
            </div>
          </header>
          <form id="profile-form" class="stack">
            <label class="field" for="account-username">
              <span>ユーザー名</span>
              <input
                id="account-username"
                type="text"
                name="username"
                autocomplete="username"
                required
              />
            </label>
            <!-- displayName removed: not collected or stored -->
            <div class="button-row align-start">
              <button type="submit" class="primary">変更を保存</button>
            </div>
          </form>
        </div>

        <div class="card">
          <header class="section-header">
            <div>
              <h2>パスキー</h2>
              <p class="hint">
                新しいデバイスを登録したり、不要な鍵を削除できます。
              </p>
            </div>
            <div class="section-actions">
              <button
                type="button"
                id="add-passkey"
                class="secondary accent"
              >
                別の鍵を追加
              </button>
            </div>
          </header>
          <ul id="credential-list" class="credentials">
            <li class="empty">サインインするとパスキーが表示されます。</li>
          </ul>
        </div>
      </section>

      <dialog id="passkey-dialog">
        <form id="passkey-form" class="dialog-form">
          <h2 id="passkey-dialog-title">パスキーを追加</h2>
          <p id="passkey-dialog-description" class="hint">
            このユーザー名に最初のパスキーを登録します。
          </p>
          <div class="button-row align-end">
            <button type="button" id="cancel-passkey-dialog" class="secondary">
              キャンセル
            </button>
            <button type="submit" id="submit-passkey-dialog" class="primary">
              続行
            </button>
          </div>
        </form>
      </dialog>

      <!-- Sign-in modal for browsers without conditional mediation -->
      <dialog id="signin-dialog">
        <form id="signin-form" class="dialog-form">
          <h2>サインイン</h2>
          <p class="hint">ユーザー名を入力してパスキーでサインインします。</p>
          <label class="field" for="signin-username">
            <span>ユーザー名</span>
            <input
              id="signin-username"
              name="username"
              autocomplete="username"
              type="text"
              required
            />
          </label>
          <div class="button-row align-end">
            <button type="button" id="cancel-signin" class="secondary">
              キャンセル
            </button>
            <button type="submit" id="submit-signin" class="primary">
              サインイン
            </button>
          </div>
        </form>
      </dialog>
    </main>

    <div class="toast-region" aria-live="polite" aria-atomic="true">
      <div
        class="toast"
        id="status"
        data-status="info"
        data-visible="true"
        role="status"
      >
        準備が整いました。
      </div>
    </div>

    <script type="module">
      import { createClient } from "/webauthn/client.js";

      const client = createClient();

      // localStorage-based username persistence removed intentionally

      const statusEl = document.getElementById("status");
      const guestView = document.getElementById("guest-view");
      const accountView = document.getElementById("account-view");
      const guestForm = document.getElementById("guest-form");
      // guest username input removed from DOM; we keep storage key
      // and will generate usernames when needed
      const guestUsernameInput = null;
      const conditionalStatus = document.getElementById(
        "conditional-status",
      );
      const accountSummary = document.getElementById("account-summary");
      const logoutButton = document.getElementById("logout");
      const deleteAccountButton = document.getElementById(
        "delete-account",
      );
      const profileForm = document.getElementById("profile-form");
      const accountUsernameInput = document.getElementById(
        "account-username",
      );
      // displayName inputs removed
      const profileSubmitButton = profileForm.querySelector(
        'button[type="submit"]',
      );
      const addPasskeyButton = document.getElementById("add-passkey");
      const credentialsList = document.getElementById(
        "credential-list",
      );
      const passkeyDialog = document.getElementById("passkey-dialog");
      const passkeyForm = document.getElementById("passkey-form");
      const passkeyDialogTitle = document.getElementById(
        "passkey-dialog-title",
      );
      const passkeyDialogDescription = document.getElementById(
        "passkey-dialog-description",
      );
      const passkeyDisplayNameField = null;
      const passkeyDisplayNameInput = null;
      const passkeyDialogCancel = document.getElementById(
        "cancel-passkey-dialog",
      );
      const passkeyDialogSubmit = document.getElementById(
        "submit-passkey-dialog",
      );
      const signinDialog = document.getElementById("signin-dialog");
      const signinForm = document.getElementById("signin-form");
      const signinUsernameInput = document.getElementById(
        "signin-username",
      );
      const signinDialogCancel = document.getElementById(
        "cancel-signin",
      );

      const state = {
        account: null,
        credentials: [],
        conditionalAvailable: null,
      };

      let statusAnimationFrame = 0;
      let statusHideTimeout = 0;

      const hideStatus = () => {
        // hide using dataset so CSS transitions handle the visual
        statusEl.dataset.visible = "false";
        if (statusAnimationFrame) {
          cancelAnimationFrame(statusAnimationFrame);
          statusAnimationFrame = 0;
        }
        if (statusHideTimeout) {
          clearTimeout(statusHideTimeout);
          statusHideTimeout = 0;
        }
      };

      const setStatus = (
        message,
        type = "info",
        { autoHide = true, timeout = 5000 } = {},
      ) => {
        statusEl.textContent = message;
        statusEl.dataset.status = type;
        // ensure hidden first so transition can play when shown
        statusEl.dataset.visible = "false";
        if (statusAnimationFrame) {
          cancelAnimationFrame(statusAnimationFrame);
        }
        // clear any previous hide timer
        if (statusHideTimeout) {
          clearTimeout(statusHideTimeout);
          statusHideTimeout = 0;
        }
        statusAnimationFrame = requestAnimationFrame(() => {
          statusAnimationFrame = 0;
          statusEl.dataset.visible = "true";
          // schedule auto-hide if requested
          if (autoHide) {
            statusHideTimeout = setTimeout(() => {
              statusHideTimeout = 0;
              statusEl.dataset.visible = "false";
            }, timeout);
          }
        });
      };

      const formatDate = (value) => {
        try {
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return "-";
          }
          return date.toLocaleString();
        } catch {
          return "-";
        }
      };

      // username persistence functions removed — no localStorage reads/writes

      const updateViews = () => {
        const hasAccount = Boolean(state.account);
        guestView.hidden = hasAccount;
        accountView.hidden = !hasAccount;
      };

      const renderCredentials = (credentials) => {
        credentialsList.innerHTML = "";
        if (!state.account) {
          const li = document.createElement("li");
          li.className = "empty";
          li.textContent = "サインインするとパスキーが表示されます。";
          credentialsList.append(li);
          return;
        }
        if (!credentials.length) {
          const li = document.createElement("li");
          li.className = "empty";
          li.textContent = "まだパスキーが登録されていません。";
          credentialsList.append(li);
          return;
        }
        for (const credential of credentials) {
          const li = document.createElement("li");

          const header = document.createElement("div");
          header.className = "credential-header";
          const title = document.createElement("strong");
          title.textContent = credential.nickname ||
            "名前のないデバイス";
          header.append(title);

          const deleteButton = document.createElement("button");
          deleteButton.type = "button";
          deleteButton.className = "danger outline";
          deleteButton.dataset.credentialId = credential.id;
          deleteButton.textContent = "削除";
          header.append(deleteButton);
          li.append(header);

          const meta = document.createElement("div");
          meta.className = "credential-meta";

          const rows = [
            ["デバイス", credential.deviceType ?? "不明"],
            ["バックアップ", credential.backedUp ? "はい" : "いいえ"],
            ["追加日", formatDate(credential.createdAt)],
            ["更新日", formatDate(credential.updatedAt)],
            [
              "ID",
              credential.id.length > 14
                ? `${credential.id.slice(0, 6)}…${
                  credential.id.slice(-6)
                }`
                : credential.id,
            ],
          ];

          for (const [label, value] of rows) {
            const row = document.createElement("div");
            const labelEl = document.createElement("span");
            labelEl.textContent = `${label}`;
            const valueEl = document.createElement("span");
            valueEl.textContent = `${value}`;
            valueEl.style.fontWeight = "500";
            row.append(labelEl, valueEl);
            meta.append(row);
          }

          li.append(meta);
          credentialsList.append(li);
        }
      };

      const renderAccount = () => {
        const account = state.account;
        if (!account) {
          accountSummary.textContent =
            "サインインしてアカウントを管理しましょう。";
          accountUsernameInput.value = "";
          renderCredentials([]);
          updateViews();
          return;
        }
        const { user, credentials } = account;
        // displayName intentionally not shown or stored on client
        accountSummary.textContent = user.username;
        accountUsernameInput.value = user.username;
        renderCredentials(credentials);
        updateViews();
      };

      const setAccount = (account) => {
        if (account && account.user) {
          state.account = {
            user: account.user,
            credentials: Array.isArray(account.credentials)
              ? account.credentials
              : [],
          };
          state.credentials = state.account.credentials;
        } else {
          state.account = null;
          state.credentials = [];
        }
        renderAccount();
      };

      const getSession = async () => {
        try {
          const response = await fetch("/session", {
            credentials: "include",
          });
          if (!response.ok) {
            return null;
          }
          return await response.json();
        } catch {
          return null;
        }
      };

      const extractErrorMessage = async (response) => {
        try {
          const json = await response.clone().json();
          if (json && typeof json === "object" && "message" in json) {
            const message = json.message;
            if (typeof message === "string" && message.trim()) {
              return message.trim();
            }
          }
        } catch {
          // ignore
        }
        try {
          const text = await response.text();
          if (text.trim()) {
            return text.trim();
          }
        } catch {
          // ignore
        }
        return `リクエストがステータス${response.status}で失敗しました`;
      };

      const fetchAccount = async (username) => {
        const normalized = username.trim();
        if (!normalized) {
          throw new Error("ユーザー名は必須です。");
        }
        const response = await fetch(
          `/webauthn/credentials?username=${
            encodeURIComponent(normalized)
          }`,
          { credentials: "include" },
        );
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error("アカウントが見つかりません。");
          }
          throw new Error(await extractErrorMessage(response));
        }
        const data = await response.json();
        if (!data || typeof data !== "object" || !data.user) {
          throw new Error("アカウントが見つかりません。");
        }
        const credentials = Array.isArray(data.credentials)
          ? data.credentials
          : [];
        return { user: data.user, credentials };
      };

      const loadAccount = async (username) => {
        const account = await fetchAccount(username);
        setAccount(account);
        return account;
      };

      const refreshAccount = async () => {
        if (!state.account) {
          return;
        }
        const username = state.account.user.username;
        try {
          await loadAccount(username);
        } catch (error) {
          setStatus(
            error.message ?? "アカウントを更新できません。",
            "error",
          );
        }
      };

      const clearAccount = () => {
        setAccount(null);
      };

      const runPasskeyFlow = async (options = {}) => {
        const providedUsername = typeof options.username === "string"
          ? options.username.trim()
          : "";
        const hasUsername = Boolean(providedUsername);

        setStatus("パスキーの操作を待機しています…");

        const result = await client.authenticateOrRegister({
          username: hasUsername ? providedUsername : undefined,
          useAutofill: !hasUsername &&
            state.conditionalAvailable === true,
          verifyAutofillInput: false,
        });

        let resolvedUsername = hasUsername ? providedUsername : null;

        if (result.kind === "registered") {
          const nickname = result.credential?.nickname?.trim();
          setStatus(
            nickname
              ? `パスキー「${nickname}」を登録しました。`
              : "パスキーを登録しました。",
            "success",
          );
          resolvedUsername = result.username;
        } else if (!resolvedUsername) {
          resolvedUsername = result.username ?? null;
        }

        if (!resolvedUsername) {
          const session = await getSession();
          if (session?.isAuthenticated && session.user) {
            resolvedUsername = session.user.username;
          }
        }

        if (resolvedUsername) {
          await loadAccount(resolvedUsername);
        } else {
          await refreshAccount();
        }

        setStatus("サインインに成功しました。", "success");
        return resolvedUsername;
      };

      const checkConditionalMediation = async () => {
        if (typeof client.isAutofillAvailable !== "function") {
          conditionalStatus.textContent =
            "ご利用のブラウザーはまだパスキーの自動入力に対応していません。";
          conditionalStatus.dataset.state = "unsupported";
          return false;
        }
        try {
          const available = await client.isAutofillAvailable();
          state.conditionalAvailable = available;
          conditionalStatus.textContent = available
            ? "このブラウザーではパスキーの自動入力が利用できます。"
            : "パスキーの自動入力は無効です。手動でサインインできます。";
          conditionalStatus.dataset.state = available
            ? "available"
            : "absent";
          return available;
        } catch (error) {
          console.error(
            "Failed to detect conditional mediation:",
            error,
          );
          conditionalStatus.textContent =
            "パスキーの自動入力に対応しているか判定できませんでした。";
          conditionalStatus.dataset.state = "error";
          return false;
        }
      };

      guestForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (guestForm.dataset.loading === "true") {
          return;
        }
        // If conditional mediation is available, start discoverable credential flow.
        // Otherwise prompt user to provide a username manually.
        if (!state.conditionalAvailable) {
          // open a lightweight modal to let the user enter username
          try {
            signinDialog.showModal();
            signinUsernameInput.focus();
          } catch (error) {
            // fallback to status message if dialog cannot be shown
            setStatus(
              "このブラウザーではパスキーの自動入力が利用できません。アカウントを作成してください。",
              "info",
            );
          }
          return;
        }

        guestForm.dataset.loading = "true";
        try {
          await runPasskeyFlow();
        } catch (error) {
          setStatus(
            error?.message
              ? `サインインに失敗しました: ${error.message}`
              : "サインインがキャンセルされたか失敗しました。",
            "error",
          );
        } finally {
          guestForm.dataset.loading = "false";
        }
      });

      // guestUsernameInput removed — username stored when created

      const openPasskeyDialog = () => {
        passkeyDialog.dataset.mode = "add";
        passkeyDialogTitle.textContent = "別のパスキーを追加";
        passkeyDialogDescription.textContent =
          "このデバイスの情報から自動的に名前を付けて保存します。";
        passkeyDialogSubmit.textContent = "パスキーを追加";
        try {
          passkeyDialog.showModal();
          passkeyDialogSubmit.focus();
        } catch (error) {
          console.error("Unable to open dialog:", error);
        }
      };

      addPasskeyButton.addEventListener("click", () => {
        if (!state.account) {
          setStatus(
            "新しいパスキーを追加する前にサインインしてください。",
            "error",
          );
          return;
        }
        openPasskeyDialog();
      });

      passkeyDialogCancel.addEventListener("click", () => {
        passkeyDialog.close();
      });

      signinDialogCancel.addEventListener("click", () => {
        try {
          signinDialog.close();
        } catch {
          // ignore
        }
      });

      signinForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (signinForm.dataset.loading === "true") return;
        const username = (signinUsernameInput.value || "").trim();
        if (!username) {
          setStatus("ユーザー名を入力してください。", "error");
          return;
        }
        signinForm.dataset.loading = "true";
        try {
          signinDialog.close();
        } catch {}
        try {
          await runPasskeyFlow({ username });
        } catch (err) {
          setStatus(
            err?.message
              ? `サインインに失敗しました: ${err.message}`
              : "サインインに失敗しました。",
            "error",
          );
        } finally {
          signinForm.dataset.loading = "false";
        }
      });

      passkeyDialog.addEventListener("close", () => {
        passkeyForm.dataset.loading = "false";
      });

      passkeyForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (passkeyForm.dataset.loading === "true") {
          return;
        }
        passkeyForm.dataset.loading = "true";
        passkeyDialogSubmit.disabled = true;
        try {
          if (!state.account) {
            throw new Error("サインイン中のアカウントがありません。");
          }
          const username = state.account.user.username;
          setStatus("セキュリティキーの操作を待機しています…");
          const result = await client.register({ username });
          const nickname = result?.credential?.nickname?.trim();
          setStatus(
            nickname
              ? `パスキー「${nickname}」を追加しました。`
              : "パスキーを追加しました。",
            "success",
          );
          passkeyDialog.close();
          await refreshAccount();
        } catch (error) {
          let message = "パスキーの設定に失敗しました。";
          let statusType = "error";
          if (error instanceof DOMException) {
            switch (error.name) {
              case "NotAllowedError":
                message =
                  "このデバイスには既にこのアカウントのパスキーがあります。別の認証器を使用するか既存の鍵を削除してください。";
                break;
              case "InvalidStateError":
                message =
                  "この認証器は既にこのアカウントに登録されているため要求を拒否しました。";
                break;
              case "AbortError":
                message = "パスキーの設定がキャンセルされました。";
                statusType = "info";
                break;
              default:
                if (error.message?.trim()) {
                  message =
                    `パスキーの設定に失敗しました: ${error.message}`;
                }
                break;
            }
          } else if (error instanceof Error && error.message.trim()) {
            message = `パスキーの設定に失敗しました: ${error.message}`;
          }
          setStatus(message, statusType);
        } finally {
          passkeyDialogSubmit.disabled = false;
          passkeyForm.dataset.loading = "false";
        }
      });

      credentialsList.addEventListener("click", async (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const button = target.closest("button[data-credential-id]");
        if (!(button instanceof HTMLButtonElement)) {
          return;
        }
        if (!state.account) {
          setStatus(
            "パスキーを管理する前にサインインしてください。",
            "error",
          );
          return;
        }
        const credentialId = button.dataset.credentialId;
        if (!credentialId) {
          return;
        }
        if (button.dataset.loading === "true") {
          return;
        }
        button.dataset.loading = "true";
        button.disabled = true;
        try {
          setStatus("パスキーを削除しています…");
          await client.delete({
            username: state.account.user.username,
            credentialId,
          });
          setStatus("パスキーを削除しました。", "success");
          await refreshAccount();
        } catch (error) {
          setStatus(
            error?.message
              ? `パスキーの削除に失敗しました: ${error.message}`
              : "パスキーの削除に失敗しました。",
            "error",
          );
        } finally {
          button.dataset.loading = "false";
          button.disabled = false;
        }
      });

      profileForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!state.account) {
          setStatus(
            "プロフィールを更新する前にサインインしてください。",
            "error",
          );
          return;
        }
        if (profileForm.dataset.loading === "true") {
          return;
        }
        const username = accountUsernameInput.value.trim();
        const payload = {};
        if (username && username !== state.account.user.username) {
          payload.username = username;
        }
        if (Object.keys(payload).length === 0) {
          setStatus("保存する変更がありません。", "info");
          return;
        }
        profileForm.dataset.loading = "true";
        profileSubmitButton.disabled = true;
        try {
          const response = await fetch("/account", {
            method: "PATCH",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          const data = await response.json();
          if (!data || typeof data !== "object" || !data.user) {
            throw new Error("サーバーから予期しない応答がありました。");
          }
          state.account = {
            user: data.user,
            credentials: state.credentials,
          };
          renderAccount();
          setStatus("プロフィールを更新しました。", "success");
        } catch (error) {
          setStatus(
            error?.message
              ? `プロフィールの保存に失敗しました: ${error.message}`
              : "プロフィールの保存に失敗しました。",
            "error",
          );
        } finally {
          profileForm.dataset.loading = "false";
          profileSubmitButton.disabled = false;
        }
      });

      logoutButton.addEventListener("click", async () => {
        if (logoutButton.dataset.loading === "true") {
          return;
        }
        logoutButton.dataset.loading = "true";
        logoutButton.disabled = true;
        try {
          const response = await fetch("/session/logout", {
            method: "POST",
            credentials: "include",
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          clearAccount();
          setStatus("サインアウトしました。", "info");
        } catch (error) {
          setStatus(
            error?.message
              ? `サインアウトに失敗しました: ${error.message}`
              : "サインアウトに失敗しました。",
            "error",
          );
        } finally {
          logoutButton.dataset.loading = "false";
          logoutButton.disabled = false;
        }
      });

      deleteAccountButton.addEventListener("click", async () => {
        if (!state.account) {
          setStatus(
            "アカウントを削除する前にサインインしてください。",
            "error",
          );
          return;
        }
        if (deleteAccountButton.dataset.loading === "true") {
          return;
        }
        const confirmed = window.confirm(
          "アカウントを削除するとすべてのパスキーが消えます。この操作は取り消せません。続行しますか？",
        );
        if (!confirmed) {
          return;
        }
        deleteAccountButton.dataset.loading = "true";
        deleteAccountButton.disabled = true;
        try {
          const response = await fetch("/account", {
            method: "DELETE",
            credentials: "include",
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          clearAccount();
          setStatus("アカウントを削除しました。", "success");
        } catch (error) {
          setStatus(
            error?.message
              ? `アカウントの削除に失敗しました: ${error.message}`
              : "アカウントの削除に失敗しました。",
            "error",
          );
        } finally {
          deleteAccountButton.dataset.loading = "false";
          deleteAccountButton.disabled = false;
        }
      });

      const initialise = async () => {
        // Nothing to prefill on the guest view; stored username remains
        // for sign-in if previously created.
        await checkConditionalMediation();
        const session = await getSession();
        if (session?.isAuthenticated && session.user) {
          try {
            await loadAccount(session.user.username);
            setStatus("おかえりなさい。", "success");
            return;
          } catch (error) {
            console.error("Failed to restore session:", error);
            clearAccount();
            setStatus(
              "セッションを復元できませんでした。もう一度サインインしてください。",
              "error",
            );
            return;
          }
        }
        clearAccount();
        setStatus("準備が整いました。", "info");
      };

      await initialise();

      // click-to-dismiss for the toast region: hide immediately when clicked
      statusEl.addEventListener("click", () => {
        // hide immediately and clear any timers
        if (statusHideTimeout) {
          clearTimeout(statusHideTimeout);
          statusHideTimeout = 0;
        }
        // use requestAnimationFrame to ensure dataset changes don't clash
        if (statusAnimationFrame) {
          cancelAnimationFrame(statusAnimationFrame);
          statusAnimationFrame = 0;
        }
        statusEl.dataset.visible = "false";
      });
    </script>
  </body>
</html>
