<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>kbn.one ID</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="sign-in page">
      <header class="page-header">
        <div class="brand">
          <h1 id="brand">kbn.one ID</h1>
        </div>
      </header>

      <section id="guest-view" class="panel">
        <div class="card">
          <form id="guest-form" class="stack" autocomplete="off">
            <div class="button-row align-start">
              <button type="submit" class="primary">
                パスキーでサインイン
              </button>
              <button
                type="button"
                id="open-create-account"
                class="secondary"
              >
                アカウントを作成
              </button>
            </div>
          </form>
          <p id="conditional-status" class="hint" data-state="pending">
            パスキーの自動入力に対応しているか確認しています…
          </p>
        </div>
      </section>
    </main>

    <dialog id="signin-dialog">
      <form id="signin-form" class="dialog-form">
        <h2>サインイン</h2>
        <p class="hint">ユーザー名を入力してパスキーでサインインします。</p>
        <label class="field" for="signin-username">
          <span>ユーザー名</span>
          <input
            id="signin-username"
            name="username"
            autocomplete="username"
            type="text"
            required
          />
        </label>
        <div class="button-row align-end">
          <button type="button" id="cancel-signin" class="secondary">
            キャンセル
          </button>
          <button type="submit" id="submit-signin" class="primary">
            サインイン
          </button>
        </div>
      </form>
    </dialog>
    <script type="module">
      import {
        createClient,
        startAuthentication,
      } from "/webauthn/client.js";

      const client = createClient();

      const guestForm = document.getElementById("guest-form");
      const conditionalStatus = document.getElementById(
        "conditional-status",
      );
      const createAccountButton = document.getElementById(
        "open-create-account",
      );
      const signinDialog = document.getElementById("signin-dialog");
      const signinForm = document.getElementById("signin-form");
      const signinUsernameInput = document.getElementById(
        "signin-username",
      );
      const signinDialogCancel = document.getElementById(
        "cancel-signin",
      );

      const state = {
        conditionalAvailable: false,
      };

      let defaultStatusText = conditionalStatus.textContent;
      let defaultStatusState = conditionalStatus.dataset.state ||
        "pending";
      let statusResetTimeout = 0;

      const updateDefaultStatus = (message, status) => {
        defaultStatusText = message;
        defaultStatusState = status;
      };

      const setStatus = (
        message,
        status = "info",
        { autoHide = false, timeout = 4000 } = {},
      ) => {
        if (statusResetTimeout) {
          clearTimeout(statusResetTimeout);
          statusResetTimeout = 0;
        }
        conditionalStatus.textContent = message;
        conditionalStatus.dataset.state = status;
        if (autoHide) {
          statusResetTimeout = setTimeout(() => {
            statusResetTimeout = 0;
            conditionalStatus.textContent = defaultStatusText;
            conditionalStatus.dataset.state = defaultStatusState;
          }, timeout);
        }
      };

      const getSession = async () => {
        try {
          const response = await fetch("/session", {
            credentials: "include",
          });
          if (!response.ok) {
            return null;
          }
          return await response.json();
        } catch {
          return null;
        }
      };

      const redirectToDashboard = async () => {
        const session = await getSession();
        if (session?.isAuthenticated && session.user) {
          window.location.href = "/me";
          return true;
        }
        throw new Error(
          "サインインできませんでした。もう一度お試しください。",
        );
      };

      const authenticateWithPasskey = async (username) => {
        setStatus("パスキーの操作を待機しています…");
        if (username) {
          await client.authenticate({ username });
          await redirectToDashboard();
          setStatus("サインインに成功しました。", "success", {
            autoHide: true,
          });
          return;
        }
        if (!state.conditionalAvailable) {
          throw new Error("ユーザー名が必要です。");
        }
        const optsResp = await fetch("/webauthn/authenticate/options", {
          method: "POST",
          credentials: "include",
          body: JSON.stringify({}),
        });
        if (!optsResp.ok) {
          throw new Error("認証オプションの取得に失敗しました。");
        }
        const optionsJSON = await optsResp.json();
        const assertionResponse = await startAuthentication({
          optionsJSON,
        });
        const verifyResp = await fetch(
          "/webauthn/authenticate/verify",
          {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              credential: assertionResponse,
              challenge: optionsJSON.challenge,
              origin: window.location.origin,
            }),
          },
        );
        if (!verifyResp.ok) {
          throw new Error("認証の検証に失敗しました。");
        }
        await redirectToDashboard();
        setStatus("サインインに成功しました。", "success", {
          autoHide: true,
        });
      };

      const checkConditionalMediation = async () => {
        if (
          typeof PublicKeyCredential === "undefined" ||
          typeof PublicKeyCredential.isConditionalMediationAvailable !==
            "function"
        ) {
          conditionalStatus.textContent =
            "ご利用のブラウザーはまだパスキーの自動入力に対応していません。";
          conditionalStatus.dataset.state = "unsupported";
          updateDefaultStatus(
            conditionalStatus.textContent,
            conditionalStatus.dataset.state,
          );
          state.conditionalAvailable = false;
          return false;
        }
        try {
          const available = await PublicKeyCredential
            .isConditionalMediationAvailable();
          state.conditionalAvailable = available;
          conditionalStatus.textContent = available
            ? "このブラウザーではパスキーの自動入力が利用できます。"
            : "パスキーの自動入力は無効です。手動でサインインできます。";
          conditionalStatus.dataset.state = available
            ? "available"
            : "absent";
          updateDefaultStatus(
            conditionalStatus.textContent,
            conditionalStatus.dataset.state,
          );
          return available;
        } catch (error) {
          console.error(
            "Failed to detect conditional mediation:",
            error,
          );
          conditionalStatus.textContent =
            "パスキーの自動入力に対応しているか判定できませんでした。";
          conditionalStatus.dataset.state = "error";
          updateDefaultStatus(
            conditionalStatus.textContent,
            conditionalStatus.dataset.state,
          );
          state.conditionalAvailable = false;
          return false;
        }
      };

      const generateRandomUsername = () => {
        const hex = () =>
          Math.floor(Math.random() * 0xffff)
            .toString(16)
            .padStart(4, "0");
        return `kbn-${Date.now().toString(36)}-${hex()}`;
      };

      guestForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (guestForm.dataset.loading === "true") {
          return;
        }
        if (!state.conditionalAvailable) {
          try {
            signinDialog.showModal();
            signinUsernameInput.focus();
          } catch (error) {
            console.error("Failed to open sign-in dialog:", error);
            setStatus(
              "このブラウザーではパスキーの自動入力が利用できません。アカウントを作成するかユーザー名でサインインしてください。",
              "info",
            );
          }
          return;
        }
        guestForm.dataset.loading = "true";
        try {
          await authenticateWithPasskey("");
        } catch (error) {
          setStatus(
            error?.message
              ? `サインインに失敗しました: ${error.message}`
              : "サインインがキャンセルされたか失敗しました。",
            "error",
          );
        } finally {
          guestForm.dataset.loading = "false";
        }
      });

      createAccountButton.addEventListener("click", async () => {
        if (createAccountButton.dataset.loading === "true") {
          return;
        }
        const username = generateRandomUsername();
        createAccountButton.dataset.loading = "true";
        createAccountButton.disabled = true;
        try {
          setStatus("セキュリティキーの操作を待機しています…");
          await client.register({ username });
          await redirectToDashboard();
          setStatus("アカウントを作成しました。", "success", {
            autoHide: true,
          });
        } catch (error) {
          let message = "パスキーの設定に失敗しました。";
          let statusType = "error";
          if (error instanceof DOMException) {
            switch (error.name) {
              case "NotAllowedError":
                message =
                  "このデバイスには既にこのアカウントのパスキーがあります。別の認証器を使用するか既存の鍵を削除してください。";
                break;
              case "InvalidStateError":
                message =
                  "この認証器は既にこのアカウントに登録されているため要求を拒否しました。";
                break;
              case "AbortError":
                message = "パスキーの設定がキャンセルされました。";
                statusType = "info";
                break;
              default:
                if (error.message?.trim()) {
                  message =
                    `パスキーの設定に失敗しました: ${error.message}`;
                }
                break;
            }
          } else if (error instanceof Error && error.message.trim()) {
            message = `パスキーの設定に失敗しました: ${error.message}`;
          }
          setStatus(message, statusType);
        } finally {
          createAccountButton.dataset.loading = "false";
          createAccountButton.disabled = false;
        }
      });

      signinDialogCancel.addEventListener("click", () => {
        try {
          signinDialog.close();
        } catch (error) {
          console.error("Failed to close sign-in dialog:", error);
        }
      });

      signinForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (signinForm.dataset.loading === "true") return;
        const username = (signinUsernameInput.value || "").trim();
        if (!username) {
          setStatus("ユーザー名を入力してください。", "error");
          return;
        }
        signinForm.dataset.loading = "true";
        try {
          signinDialog.close();
        } catch {
          // ignore
        }
        try {
          await authenticateWithPasskey(username);
        } catch (error) {
          setStatus(
            error?.message
              ? `サインインに失敗しました: ${error.message}`
              : "サインインに失敗しました。",
            "error",
          );
        } finally {
          signinForm.dataset.loading = "false";
        }
      });

      const initialise = async () => {
        await checkConditionalMediation();
        const session = await getSession();
        if (session?.isAuthenticated && session.user) {
          window.location.href = "/me";
          return;
        }
      };

      await initialise();

      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/sw.js").catch((error) => {
          console.warn("Service worker registration failed", error);
        });
      }
    </script>
  </body>
</html>
